package test;

import Main.Transaction;
import Main.TxHandler;
import Main.UTXO;
import Main.UTXOPool;
import org.junit.Test;
import org.junit.Before;
import java.math.BigInteger;
import java.security.*;
import static junit.framework.TestCase.assertFalse;
import static org.hamcrest.core.Is.is;
import static org.junit.Assert.*;


/** 
* Main.TxHandler Tester.
* @author <RAMBO,PHBS,1901212580>
* Main Idea of Design:
 * Part I- Test IsValidTx(tx):
 * create different invalid transactions(they only violates one requirement at one time) in choronological order seperately, to see whether the method can detect these invalidnesses
 * Part II- Test HandleTxs(possible txs[]):
 * create a list of transactions which contains double spending, to see whether the method can return a right list
* Structure of this test project:
 * 'before()' used for intialzing some parameters and setting for further testing
 * 'testIsValidTxreq1' ~ 'testIsValidTxreq5' verifys each function in method 'isValidTx'
 * 'testHandleTxs' verifys method 'handleTxs'
*/

public class TxHandlerTest {

    // Instantiate several keypairs
    KeyPair scrooge_key;
    KeyPair rambo1key;
    KeyPair rambo2key;
    KeyPair rambo3key;

    UTXOPool utxoPool1 = new UTXOPool();
    Transaction[] possibletxs1 = new Transaction[3];
    Transaction[] possibletxs2 = new Transaction[2];
    Transaction tx1 = new Transaction();
    Transaction tx2 = new Transaction();
    Transaction tx3 = new Transaction();
    Transaction tx4 = new Transaction();
    Transaction tx5 = new Transaction();
    Transaction tx6 = new Transaction();
    Transaction tx7 = new Transaction();
    Transaction tx8 = new Transaction();
    Transaction tx9 = new Transaction();
    Transaction tx10 = new Transaction();
    Transaction tx11 = new Transaction();


    @Before
    public void before() throws Exception {
        // Instantiate several transactions


        this.scrooge_key = KeyPairGenerator.getInstance("RSA").generateKeyPair();
        this.rambo1key = KeyPairGenerator.getInstance("RSA").generateKeyPair();
        this.rambo2key = KeyPairGenerator.getInstance("RSA").generateKeyPair();
        this.rambo3key = KeyPairGenerator.getInstance("RSA").generateKeyPair();


        // CreateCoin Main.Transaction, create a transaction 'tx1', give 50,80,100,150,200 coins to Scrooge
        // the inital hash of this tx1 is generated by byte '0'
        byte[] initialhash = BigInteger.valueOf(0).toByteArray();
        tx1.addInput(initialhash, 0);
        tx1.signTx(scrooge_key.getPrivate(), 0);
        tx1.addOutput(50, scrooge_key.getPublic());
        tx1.addOutput(80, scrooge_key.getPublic());
        tx1.addOutput(100, scrooge_key.getPublic());
        tx1.addOutput(150, scrooge_key.getPublic());
        tx1.addOutput(200, scrooge_key.getPublic());

        // Set up the initial utxoPool, put the previous Create Coin's utxo into this pool
        // There exists three utxo now in the utxoPool
        UTXO utxo1 = new UTXO(tx1.getHash(), 0);
        UTXO utxo2 = new UTXO(tx1.getHash(), 1);
        UTXO utxo3 = new UTXO(tx1.getHash(), 2);
        UTXO utxo4 = new UTXO(tx1.getHash(), 3);
        UTXO utxo5 = new UTXO(tx1.getHash(), 4);
        utxoPool1.addUTXO(utxo1, tx1.getOutput(0));
        utxoPool1.addUTXO(utxo2, tx1.getOutput(1));
        utxoPool1.addUTXO(utxo3, tx1.getOutput(2));
        utxoPool1.addUTXO(utxo4, tx1.getOutput(3));
        utxoPool1.addUTXO(utxo5, tx1.getOutput(4));


    }


    /**
     * Method: isValidTx(Main.Transaction tx)
     */
    @Test
    public void testIsValidTxreq1() throws Exception {

        // verify requirement (1): All outputs claimed by certain tx is in the current utxoPool
        // design logic: create a tx whose input is not in the current utxoPool
        //before();


        // Create the second transaction
        // the input of transaction2 is a fake hash byte consisting all '1's
        // the output of transaction2 is for two person: 25 for rambo1
        // in the end, assume Scrooge signed this tx2 using his private key
        byte[] fakehash1 = BigInteger.valueOf(1).toByteArray();
        tx2.addInput(fakehash1, 0);
        tx2.signTx(scrooge_key.getPrivate(), 0);
        tx2.addOutput(50, rambo1key.getPublic());
        TxHandler txHandler = new TxHandler(utxoPool1);
        // But since the claimed tx2[0] has not been added into the utxoPool, the return should be false
        assertFalse(txHandler.isValidTx(tx2));
    }

    @Test
    public void testIsValidTxreq2() throws Exception {
        // verify requirement (2): the signature on each input is valid
        // design logic: If Scrooge sent 50 coin to Rambo1(tx3), but Rambo2 wants to claim these coins(tx4)
        tx3.addInput(tx1.getHash(), 0);
        tx3.signTx(scrooge_key.getPrivate(), 0);
        tx3.addOutput(50, rambo1key.getPublic());
        tx4.addInput(tx1.getHash(), 0);
        tx4.signTx(rambo2key.getPrivate(), 0);
        tx4.addOutput(50, rambo2key.getPublic());
        TxHandler txHandler = new TxHandler(utxoPool1);
        // Rambo2 cannot claim the 50 coin by signing by himself, this signature is invalid, the return should be false
        assertFalse(txHandler.isValidTx(tx4));
    }



    @Test
    public void testIsValidTxreq3() throws Exception {
        // verify requirement (3): no UTXO is claimed multiple times by certain transactions
        // design logic: create two transactions(tx5& tx6) that claim the same utxo(utxo2) in the utxoPool, this should not pass
        tx5.addInput(tx1.getHash(), 1);
        tx5.signTx(scrooge_key.getPrivate(), 0);
        tx5.addOutput(80, rambo1key.getPublic());
        tx6.addInput(tx1.getHash(), 1);
        tx6.signTx(scrooge_key.getPrivate(), 0);
        tx6.addOutput(80, rambo2key.getPublic());
        TxHandler txHandler = new TxHandler(utxoPool1);
        // If Scrooge wants to destroy utxo2 by claiming them twice, this should return false
        assertFalse(txHandler.isValidTx(tx6));
    }



    @Test
    public void testIsValidTxreq4() throws Exception {
        // verify requirement (4): all of transaction output values are non-negative
        // design logic: create a transaction whose output value is negative
        tx7.addInput(tx1.getHash(), 2);
        tx7.signTx(scrooge_key.getPrivate(), 0);
        tx7.addOutput(-100, rambo1key.getPublic());
        TxHandler txHandler = new TxHandler(utxoPool1);
        // Since the output value<0, this should return false
        assertFalse(txHandler.isValidTx(tx7));
    }

    @Test
    public void testIsValidTxreq5() throws Exception {
        // verify requirement (5): the sum of the transaction input should >= the sum of its output
        // design logic: create a transaction whose output is bigger than its input
        tx8.addInput(tx1.getHash(), 2);
        tx8.signTx(scrooge_key.getPrivate(), 0);
        tx8.addOutput(110, rambo1key.getPublic());
        TxHandler txHandler = new TxHandler(utxoPool1);
        // Since the output value >input value, this should return false
        assertFalse(txHandler.isValidTx(tx8));
    }




    /**
     * Method: handleTxs(Main.Transaction[] possibleTxs)
     * design logic: design a list of possible transaction which contains double spending, then see whether the method 'handleTxs' functions
     */
    @Test
    public void testHandleTxs() throws Exception {
        TxHandler txHandler = new TxHandler(utxoPool1);

        // Create three valid transactions(tx9& tx10& tx11), send them to method 'HandleTxs'
        // tx9: S->Rambo1, 150coins
        // tx10: S->Rambo2, 200coins
        // tx11: S->Rambo3, 150coins
        // the input of the 'handleTxs' method is possibletxs1[], add each tx created into this list
        tx9.addInput(tx1.getHash(), 3);
        tx9.addOutput(150, rambo1key.getPublic());
        tx9.signTx(scrooge_key.getPrivate(), 0);
        possibletxs1[0] = tx9;

        tx10.addInput(tx1.getHash(), 4);
        tx10.addOutput(200, rambo2key.getPublic());
        tx10.signTx(scrooge_key.getPrivate(), 0);
        possibletxs1[1] = tx10;

        tx11.addInput(tx1.getHash(), 3);
        tx11.addOutput(150, rambo3key.getPublic());
        tx11.signTx(scrooge_key.getPrivate(), 0);
        possibletxs1[2] = tx11;

        // the right return should be possibletxs2: [tx9,tx10]
        possibletxs2[0] = tx9;
        possibletxs2[1] = tx10;

        // To see whether each transaction in the list is valid
        System.out.println(txHandler.isValidTx(tx9));
        System.out.println(txHandler.isValidTx(tx10));
        System.out.println(txHandler.isValidTx(tx11));

        // The handleTx should return list[tx9,tx10], because tx11 involves double spending
        assertThat(possibletxs2,is(txHandler.handleTxs(possibletxs1)));

    }


}


